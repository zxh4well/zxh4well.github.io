<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_Bart_Simpson_Skate_32px.net.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_Bart_Simpson_Skate_16px.net.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|kaiti:300,300italic,400,400italic,700,700italic|Amita:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="面向对象的三大特性面向对象有三大特性，分别是：封装、继承、多态。接下来咋们就谈谈这三大特性。 封装封装指的是隐藏对象中一些不希望被外部所访问到的属性或方法——隐匿。   其实，Python没办法做到完全隐匿信息，原因在于Python是一门解释性语言，不是汇编型语言，无法进行加密，这里说的所有的封装，都是假性的，只是为了规划代码中方法的调用。 学习重点是如何隐藏一个对象中的属性？ 我们已经知道，通常">
<meta name="keywords" content="Python进阶">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象三特性">
<meta property="og:url" content="https://zxh4well.github.io/2020/02/07/PY14三特性/index.html">
<meta property="og:site_name" content="安好">
<meta property="og:description" content="面向对象的三大特性面向对象有三大特性，分别是：封装、继承、多态。接下来咋们就谈谈这三大特性。 封装封装指的是隐藏对象中一些不希望被外部所访问到的属性或方法——隐匿。   其实，Python没办法做到完全隐匿信息，原因在于Python是一门解释性语言，不是汇编型语言，无法进行加密，这里说的所有的封装，都是假性的，只是为了规划代码中方法的调用。 学习重点是如何隐藏一个对象中的属性？ 我们已经知道，通常">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://images.cnblogs.com/cnblogs_com/clongge/o_OOBase.gif">
<meta property="og:image" content="https://i.loli.net/2020/02/29/IGFpLo8UjriZcda.png">
<meta property="og:updated_time" content="2020-03-01T11:26:45.437Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面向对象三特性">
<meta name="twitter:description" content="面向对象的三大特性面向对象有三大特性，分别是：封装、继承、多态。接下来咋们就谈谈这三大特性。 封装封装指的是隐藏对象中一些不希望被外部所访问到的属性或方法——隐匿。   其实，Python没办法做到完全隐匿信息，原因在于Python是一门解释性语言，不是汇编型语言，无法进行加密，这里说的所有的封装，都是假性的，只是为了规划代码中方法的调用。 学习重点是如何隐藏一个对象中的属性？ 我们已经知道，通常">
<meta name="twitter:image" content="https://images.cnblogs.com/cnblogs_com/clongge/o_OOBase.gif">

<link rel="canonical" href="https://zxh4well.github.io/2020/02/07/PY14三特性/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>面向对象三特性 | 安好</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">安好</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>文章</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zxh4well.github.io/2020/02/07/PY14三特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/TP.jpg">
      <meta itemprop="name" content="IF">
      <meta itemprop="description" content="心之所向 素履以往">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安好">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面向对象三特性
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-07 13:07:21" itemprop="dateCreated datePublished" datetime="2020-02-07T13:07:21+08:00">2020-02-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PY/" itemprop="url" rel="index">
                    <span itemprop="name">PY</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h1><p>面向对象有三大特性，分别是：封装、继承、多态。接下来咋们就谈谈这三大特性。<br><img src="https://images.cnblogs.com/cnblogs_com/clongge/o_OOBase.gif" alt="特性"></p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装指的是隐藏对象中一些不希望被外部所访问到的属性或方法——隐匿。  </p>
<p>其实，Python没办法做到完全隐匿信息，原因在于Python是一门解释性语言，不是汇编型语言，无法进行加密，这里说的所有的封装，都是假性的，只是为了规划代码中方法的调用。</p>
<pre><code>学习重点是如何隐藏一个对象中的属性？
</code></pre><p>我们已经知道，通常我们调用一个对象中的属性的方法是<code>对象.属性名</code>，如果我们想要隐藏一个属性的话，最好的方法就是为该属性取一个谁都不知道的名字，而你可以通过一些公开的方法来对该属性进行修改，这样该属性才是被真正的封装起来了。  </p>
<p>Python提供了一些方法来隐藏属性，可以在类中定义属性时使用双下划线开头，<code>__xxx</code>的方式进行隐藏。双下划线开头的属性，是对象的隐藏属性，隐藏属性<code>只能</code>在类的内部访问，<code>无法</code>通过对象访问。  </p>
<p>其实隐藏属性只不过是Python自动为属性改了一个名字,实际上是将名字修改为了，<em>类名<strong>属性名 比如 </strong>name -&gt; </em>类名__name。   </p>
<p>如何获取（修改）对象中的属性？那我们就需要在定义类的时候定义一些操作属性的方法</p>
<ul>
<li><p>可以提供一个getter和setter方法使外部可以访问到属性</p>
<ul>
<li>getter 获取对象中的指定属性（get_属性名）</li>
<li>setter 用来设置对象的指定属性（set_属性名）</li>
</ul>
</li>
<li><p>使用封装，确实增加了类的定义的复杂程度，但是它也确保了数据的安全性（相对安全）：</p>
<pre><code>1.隐藏了属性名，使调用者无法随意的修改对象中的属性
2.增加了getter和setter方法，很好的控制的属性的读写性
    如果希望属性是只读的，则可以直接去掉setter方法
    如果希望属性不能被外部访问，则可以直接去掉getter方法
3.使用setter方法设置属性，可以增加数据的验证，确保数据的值是正确的
4.使用getter方法获取属性，使用setter方法设置属性，可以在读取属性和修改属性的同时做一些其他的处理
5.使用getter方法可以表示一些计算的属性
</code></pre><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        表示矩形的类</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,width,height)</span>:</span></span><br><span class="line">        self.__width = width</span><br><span class="line">        self.__height = height</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_width</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__width</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_height</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__height   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_width</span><span class="params">(self , width)</span>:</span></span><br><span class="line">        self.__width = width </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_height</span><span class="params">(self , height)</span>:</span></span><br><span class="line">        self.__height = height </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_area</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__width * self.__height        </span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个对象，长5，宽3</span></span><br><span class="line">rec1 = Rectangle(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试直接访问rec1的__width</span></span><br><span class="line"><span class="comment"># print(rec1.__width) # AttributeError: 'Rectangle' object has no attribute '__width'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过_类名__属性名，访问rec1的__width属性</span></span><br><span class="line">print(rec1._Rectangle__width) <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 思考可不可以利用如下方式修改rec1的width</span></span><br><span class="line">rec1.__width = <span class="number">8</span></span><br><span class="line">print(rec1.__width) <span class="comment"># 8</span></span><br><span class="line"><span class="comment"># 似乎一切都很正常，实际运行代码也不会出现错误，这是正确的吗？我们只需要小小的试验一下</span></span><br><span class="line"><span class="comment"># 如果我们真的修改了__width属性的值，无论以那种方式访问，那__width的值都因该时修改后的值——8</span></span><br><span class="line">print(rec1._Rectangle__width) <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果是5，说明我们并没有真正的改变__width的值</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">那上面的结果是何原因呢，是因为我们创建了一个名叫rec1.__width ，并且给该变量赋值8，然后再输出当然就没有问题了，</span></span><br><span class="line"><span class="string">但实质上我们并没有改变rec1对象的__width属性的值</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过set_width方法来修改对象属性值</span></span><br><span class="line">rec1.set_width(<span class="number">10000</span>)</span><br><span class="line">print(<span class="string">'The rec1._Rectangle__width = '</span>,rec1._Rectangle__width) <span class="comment">#  The rec1._Rectangle__width =  10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过get_area方法来得到面积</span></span><br><span class="line">area = rec1.get_area()</span><br><span class="line">print(area) <span class="comment"># 30000</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通过property装饰器，可以将一个get方法，转换为<code>对象的属性</code>，添加为property装饰器以后，我们就可以像调用属性一样使用get方法，setter方法也可以这样简化（稍微不同）</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line">    <span class="comment"># 添加为property装饰器以后，我们就可以像调用属性一样使用get方法</span></span><br><span class="line">    <span class="comment"># 使用property装饰的方法，必须和属性名是一样的---IMPORTANT</span></span><br><span class="line"><span class="meta">    @property    </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'get_name方法被执行'</span>)</span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># setter方法的装饰器：@属性名.setter</span></span><br><span class="line"><span class="meta">    @name.setter    </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self , name)</span>:</span></span><br><span class="line">        print(<span class="string">'setter name方法被调用'</span>)</span><br><span class="line">        self._name = name        </span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'get_age方法被执行'</span>)</span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter    </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self , age)</span>:</span></span><br><span class="line">        print(<span class="string">'setter age方法被调用'</span>)</span><br><span class="line">        self._age = age   </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 定义一个对象</span></span><br><span class="line">p = Person(<span class="string">'张三'</span>,<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用方法属性化来修改对象的属性</span></span><br><span class="line">p.name = <span class="string">'孙悟空'</span><span class="comment"># setter name方法被调用</span></span><br><span class="line">p.age = <span class="number">28</span><span class="comment"># setter age方法被调用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(p.name,p.age)</span><br><span class="line"><span class="comment"># get_name方法被执行</span></span><br><span class="line"><span class="comment"># get_age方法被执行</span></span><br><span class="line"><span class="comment"># 孙悟空 28</span></span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是什么？汉语中的继承是指某人得到了父辈或者祖辈传下来的东西。代码中的继承其实也是类似的，通过继承可以直接让子类获取到父类的方法或属性，避免重复编码，符合OCP原则，并且经常通过使用继承来对一个类进行扩展。</p>
<pre><code>重点importance：

    1、通过继承——可以让一个类获取到其他类中的属性和方法（综述）
    2、通过在类得继承机制增强了代码的可复用性和可扩展性
    3、定义类时，可以在类名后的括号中指定当前类的父类（也译为超类、基类、super）
    4、 子类（衍生类）可以直接继承父类中的所有的属性和方法
</code></pre><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I will run!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cry</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am cry!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        print(<span class="string">"Hello! My name is %s."</span>%name)</span><br><span class="line"></span><br><span class="line">erha = Dog()</span><br><span class="line">erha.say(<span class="string">'erha'</span>)<span class="comment"># Hello! My name is erha.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试子类能否使用父类得方法</span></span><br><span class="line">erha.run()<span class="comment"># I will run! </span></span><br><span class="line"><span class="comment"># 测试成功</span></span><br></pre></td></tr></table></figure>
<p>在创建类时，如果省略了父类，则默认父类为object， object是所有类的父类，所有类都继承自object</p>
<p>   Python提供了： issubclass() 检查一个类是否是另一个类的子类<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码承接上文然后补充</span></span><br><span class="line">a = issubclass(Animal,object)</span><br><span class="line">print(a)<span class="comment"># True</span></span><br><span class="line">b = issubclass(Dog,Animal)</span><br><span class="line">print(b)<span class="comment"># True</span></span><br><span class="line"><span class="comment"># 结论：验证成功</span></span><br></pre></td></tr></table></figure></p>
<pre><code>isinstance()用来检查一个对象是否是一个类的实例,如果这个类是这个对象的父类，也会返回True,所有的对象都是object的实例
</code></pre><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>如果子类中有和父类同名的方法，则通过子类实例去调用方法时，会调用子类的方法而不是父类的方法，这个特点我们成为叫做方法的重写（override/实质是覆盖）</p>
<pre><code>为什么会出现这种现象呢？
    其实原理来自于Python自身，很类似于ES得原型链，但却不尽然，当我们调用一个对象的方法时，会优先去当前对象中寻找是否具有该方法，
    如果有则直接调用；如果没有，则去当前对象的父类中寻找，如果父类中有则直接调用父类中的方法，如果没有，则去父类的父类中寻找，
    以此类推，直到找到object，如果依然没有找到，则报错。
</code></pre><p>简单说来就是，对象调用方法得时候，首先访问创建当前对象的类，如果方法存在，直接调用；否者访问该对象的父类，如果父类中有该方法，直接调用；否者访问父类的父类（当前类的祖父类），如果有就调用，如果没有就继续往上访问，直到访问到object，如果依然没有该方法则报错。</p>
<p><img src="https://i.loli.net/2020/02/29/IGFpLo8UjriZcda.png" alt="对象.PNG"><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I will run!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cry</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am cry!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Hello! My name is %s."</span>%self.name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在当前类中重写了cry方法，请着重对比两个cry方法的不同</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cry</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"这是Dog类中的CRY0w0. %s is crying!"</span>%self.name)</span><br><span class="line"></span><br><span class="line">erha = Dog(<span class="string">'erha'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用cry方法</span></span><br><span class="line">erha.cry()<span class="comment"># 这是Dog类中的CRY0w0. erha is crying!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用一个不存在的方法，看下会报什么错</span></span><br><span class="line">erha.never() <span class="comment"># AttributeError: 'Dog' object has no attribute 'never'</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">报错 AttributeError: 'Dog' object has no attribute 'never'</span></span><br><span class="line"><span class="string">其实不只是Dog中没有，实际上Dog的父类Animal中也没有，就是说直到object中都没有never方法</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></p>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>父类中的所有方法都会被子类继承，包括特殊方法，当然特殊方法也可以重写。前面我们说了，属性通常放在特殊方法<strong>init</strong>中，所以自然，我们也可以通过重写特殊方法来达到对属性的扩展。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I will run!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cry</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am cry!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="comment"># 通常希望可以直接调用父类的__init__来初始化父类中定义的属性</span></span><br><span class="line">    <span class="comment"># super() 可以用来获取当前类的父类，并且</span></span><br><span class="line">    <span class="comment"># 通过super()方法</span></span><br><span class="line">    <span class="comment"># 调用父类方法时不需要传递 self</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">        super().__init__(name)</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Hello! My name is %s,have %d year`s old"</span> %(self.name,self.age))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在当前类中重写了cry方法，请着重对比两个cry方法的不同</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cry</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"这是Dog类中的CRY0w0. %s is crying!"</span>%self.name)</span><br><span class="line"></span><br><span class="line">erha = Dog(<span class="string">'erha'</span>,<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">erha.say()<span class="comment"># Hello! My name is erha,have 18 year`s olds</span></span><br></pre></td></tr></table></figure></p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>Python支持多重继承。也就是我们可以为一个类同时指定多个父类。在开发中没有特殊的情况，应该尽量避免使用多重继承，因为多重继承会让我们的代码过于复杂。</p>
<pre><code>如何实现：
可以在类名的( )里边添加多个类，来实现多重继承，多重继承，会使子类同时拥有多个父类，并且会获取到所有父类中的方法

方法的查找路径：
如果多个父类中有同名的方法，则会现在第一个父类中寻找，然后找第二个，然后找第三个，也就是说前边父类的方法会覆盖后边父类的方法

类名.__bases__      ：这个属性可以用来获取当前类的所有父类
</code></pre><p>继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态就是指不同的子类对象调用相同的父类方法，产生不同的执行结果。多态机制使得具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类（父类），它们（那些操作）可以通过相同的方式予以调用。由于python是动态语言，继承并不是必须得，这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p>
<pre><code>多态的作用：
         让具有细微不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同功能的函数，而不用去管是否是同一个类等细节。 
      特点：
         1、多态是调用方法的技巧，不会影响到类的内部设计；
         2、只关心对象的实例方法是否同名，不关心对象所属的类型；
         3、对象所属的类之间，继承关系可有可无；
         4、多态的好处可以增加代码的外部调用灵活度，让代码更加通用，兼容性比较强；
</code></pre><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span><span class="params">(object)</span>:</span>                          </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span><span class="params">(self)</span>:</span>      <span class="comment"># 鸭子类</span></span><br><span class="line">        print(<span class="string">"鸭子沿着地面飞起来了"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Swan</span><span class="params">(object)</span>:</span>     <span class="comment"># 天鹅类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"天鹅在空中翱翔"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plane</span><span class="params">(object)</span>:</span>     <span class="comment"># 飞机类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"飞机隆隆地起飞了"</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 实现飞的功能函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fly</span><span class="params">(obj)</span>:</span>           </span><br><span class="line">    obj.fly()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># duck = Duck()</span></span><br><span class="line"><span class="comment"># fly(duck)# 鸭子沿着地面飞起来了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># swan = Swan()</span></span><br><span class="line"><span class="comment"># fly(swan)# 天鹅在空中翱翔</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># plane = Plane()</span></span><br><span class="line"><span class="comment"># fly(plane)# 飞机隆隆地起飞了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 违反了多态的函数，只适用于一种类型的对象，无法处理其他类型对象，这样导致函数的适应性非常的差</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 做类型检查,重构一下fly功能函数，使得违背多态</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flying</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(obj , Duck):</span><br><span class="line">        <span class="comment"># 注意，向isinstance()这种函数，在开发中一般是不会使用的！</span></span><br><span class="line">        obj.fly()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Wrong Erro'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用flying函数：</span></span><br><span class="line">duck = Duck()</span><br><span class="line">flying(duck)<span class="comment"># 鸭子沿着地面飞起来了</span></span><br><span class="line"></span><br><span class="line">swan = Swan()</span><br><span class="line">flying(swan)<span class="comment"># Wrong Erro</span></span><br><span class="line"></span><br><span class="line">plane = Plane()</span><br><span class="line">flying(plane)<span class="comment"># Wrong Erro</span></span><br></pre></td></tr></table></figure>
<p>在flying函数中我们做了一个类型检查，也就是只有obj是Duck类型的对象时，才可以正常使用，其他类型的对象都无法使用该函数，这个函数就违反了多态。</p>
<ul>
<li><p>多态的具体体现：<code>len()函数</code></p>
<pre><code>  l = [1,2,3]
  s = &#39;hello&#39;
  print(len(l))
  print(len(s))
  l和s分别属于列表和字符串，而我们都可以通过len函数来计算他们的长度，却不必关心他们到底是什么类型，换句话说，只要对象中具有__len__特殊方法，就可以通过len()来获取它的长度

  注释：之所以一个对象能通过len()来获取长度，是因为对象中具有一个特殊方法__len__
</code></pre></li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>IF
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://zxh4well.github.io/2020/02/07/PY14三特性/" title="面向对象三特性">https://zxh4well.github.io/2020/02/07/PY14三特性/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Python进阶/" rel="tag"><i class="fa fa-tag"></i> Python进阶</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2020/01/25/PY13面向对象/" rel="next" title="PY面向对象">
                  <i class="fa fa-chevron-left"></i> PY面向对象
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2020/03/09/常用DOS命令汇总/" rel="prev" title="常用DOS命令汇总">
                  常用DOS命令汇总 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象的三大特性"><span class="nav-number">1.</span> <span class="nav-text">面向对象的三大特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#封装"><span class="nav-number">1.1.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">1.2.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重写"><span class="nav-number">1.2.1.</span> <span class="nav-text">重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#super"><span class="nav-number">1.2.2.</span> <span class="nav-text">super</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多重继承"><span class="nav-number">1.2.3.</span> <span class="nav-text">多重继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态"><span class="nav-number">1.3.</span> <span class="nav-text">多态</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="IF"
    src="/images/TP.jpg">
  <p class="site-author-name" itemprop="name">IF</p>
  <div class="site-description" itemprop="description">心之所向 素履以往</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:811226051@qq.com" title="E-Mail &rarr; mailto:811226051@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dear zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0
  </div>


<!--在上下两段code中添加了注释，修改了尾页面显示-->

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  


















  

  

  

  

</body>
</html>
